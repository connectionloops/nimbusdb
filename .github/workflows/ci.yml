name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_IMAGE: connectionloops/nimbusdb
  REGISTRY: docker.io

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage.out
          fail_ci_if_error: false

  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-release: ${{ steps.version.outputs.should-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate next version
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Extract version number (remove 'v' prefix)
          CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
          echo "Current version: $CURRENT_VERSION"

          # Get commits since last tag (or all commits if no tag exists)
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            # No tags exist, get all commits
            COMMITS=$(git log --pretty=format:"%s" -n 50)
          else
            # Get commits since last tag
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" 2>/dev/null || echo "")
          fi

          # Determine version bump type based on conventional commits
          BUMP_TYPE="patch"
          SHOULD_RELEASE="true"

          # Check for breaking changes first
          if echo "$COMMITS" | grep -qE "^(BREAKING CHANGE|BREAKING|feat!|!):"; then
            BUMP_TYPE="major"
          # Check for new features
          elif echo "$COMMITS" | grep -qE "^feat:"; then
            BUMP_TYPE="minor"
          # Check for fixes, perf, refactor (patch level)
          elif echo "$COMMITS" | grep -qE "^(fix|perf|refactor):"; then
            BUMP_TYPE="patch"
          # If no conventional commits found but there are commits, default to patch
          elif [ -n "$COMMITS" ] && [ "$COMMITS" != "" ]; then
            BUMP_TYPE="patch"
          else
            # No commits found, skip release
            SHOULD_RELEASE="false"
          fi

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Increment version
          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "New version: $NEW_VERSION"
          echo "Bump type: $BUMP_TYPE"
          echo "Should release: $SHOULD_RELEASE"

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, calculate-version]
    if: needs.calculate-version.outputs.should-release == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=raw,value=${{ needs.calculate-version.outputs.version }}
            type=raw,value=latest

      - name: Get commit SHA
        id: commit
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Get build date
        id: date
        run: echo "date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            VERSION=${{ needs.calculate-version.outputs.version }}
            COMMIT=${{ steps.commit.outputs.sha }}
            BUILD_DATE=${{ steps.date.outputs.date }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max

      - name: Checkout code for tagging
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Create Git Tag
        if: success()
        run: |
          TAG=${{ needs.calculate-version.outputs.version }}
          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
